(ql:quickload '(:websocket-driver-server :clack) :silent t)
(defpackage simple-app (:use :cl :clack :wsd))
(in-package :simple-app)
(defmacro f (&rest r) `(format nil ,@r))
(defclass channel ()
  ((name :initarg :name :initform (error "Name this channel!") :reader name)
   (clients :accessor clients :initform nil)))
(defvar ib (make-instance 'channel :name "ib"))
(defvar ix (make-instance 'channel :name "ix"))
(defvar iu (make-instance 'channel :name "iu"))
(defvar ob (make-instance 'channel :name "ob"))
(defvar ox (make-instance 'channel :name "ox"))
(defvar ou (make-instance 'channel :name "ou"))
(defvar *channels* (list ib ix iu ob ox ou))
(defvar *client* nil)
(defun find-channel (name)
  (find name *channels* :test #'string= :key #'name))
(defun subscribe (user channel)
  (if (stringp channel) (subscribe user (find-channel channel))
      (push user (clients channel))))
(defun unsubscribe (user channel)
  (if (stringp channel) (unsubscribe user (find-channel channel))
      (setf (clients channel) (delete user (clients channel)))))
(defun sub (user channels)
  (when channels
    (subscribe user (car channels))
    (sub user (cdr channels))))
(defun unsub (user channels)
  (when channels
    (unsubscribe user (car channels))
    (unsub user (cdr channels))))
(defun pub (channel msg)
  (if (stringp channel) (pub (find-channel channel) msg)
      (loop for client in (clients channel) do
	   (unless (eq client *client*) (funcall 'send client msg)))))
(defvar *echo-server*
  (lambda (env)
    (let ((ws (make-server env)))
      (on :message ws
	  (lambda (message)
	    (send ws message)))
      (lambda (responder)
	(declare (ignore responder))
	(start-connection ws)))))
(defun read-raw-post (req)
  (let*((h (cadr (member :headers req)))
	(f (cadr (member :raw-body req)))
	(z (parse-integer (gethash "content-length" h)))
	(a (make-array z)))
    (read-sequence a f :start 0 :end z)
    (concatenate 'string (map 'vector #'code-char a))))
(defun get-param (key req)
  (cadr (member key req)))
(defun save-file (req)
  (let ((fn (merge-pathnames "./" (subseq (get-param :path-info req) 1))))
    (with-open-file (s fn :direction :output);; :if-exists :supersede)
      (format s "~a" (read-raw-post req)))))
(defvar *app*
  (lambda (req)
    (if (eq (get-param :request-method req) :GET)
	(let ((fn (merge-pathnames "./" (subseq (get-param :path-info req) 1))))
	  `(200 (:content-type "text/plain") ,fn))
	(if (eq (get-param :request-method req) :PUT)
	    (handler-case
		(progn
		  (save-file req)
		  `(200 (:content-type "text/plain") (,(f "OK~%"))))
	      (file-error ()
		`(400 (:content-type "text/plain") (,(f "Already exists~%")))))
	    `(400 (:content-type "text/plain") (,(f "Bad Method~%")))))))
;;	    `(404 (:content-type "text/plain") (,(f "Not Found~%")))))))
(defun main ()
  (clack:clackup *echo-server* :server :wookie :port 5000)
  (clack:clackup *app* :server :woo :port 5001)
  (sleep 999999999))
